# 2021.10.11

# 练习题目：BUUCTF SimpleRev

------



## 1.概念：大小端存储

## 2.实验操作



## 1.概念：大小端存储

### 1.1大小端

大端模式：数据低位字节序存储在高位地址，高位字节序存储在低位地址

小端模式：数据低位字节序存储在低位地址，高位字节序存储在高位地址

模式相反



### 1.2计算机如何存储？

以字节为单位存储数据，一个地址单元对应一个字节，1byte=8bits. 

C语言存有不同数据类型，所占空间大小不同，大小端模式，就解决了如何存放多个字节的问题。

8bit的char，16bit的short，32bit的long

### 1.3判断模式

#### 1.3.1类型转换

在小端模式下，int i在内存中如下：

![image-20211011175229064](https://i.loli.net/2021/10/11/UZO4f1K8AzMiHCb.png)

观察可知当指针定位到01 00 00 00存储在低位地址，字节序高位存放在高地址，此时机器为小端模式，当定位到1时，即可判断

有如下c语言判断模式：

![image-20211011174711874](https://i.loli.net/2021/10/11/KCqtRmAjnYpuhGc.png)

重要语句:

`char  *a=(char *)&i;//将char类型的变量i转换为char *类型，并赋值给*a`

char * :字符指针类型，当其指向一个字符串的第一个元素时，它就可以表示这个字符串。

随着以后学习深入，再展开讲。

## 2.实验操作

------

### 2.1判断64位文件

![image-20211011191115844](https://i.loli.net/2021/10/11/wGNe3rszuqvn7F2.png)

main源码：

![image-20211011192645904](https://i.loli.net/2021/10/11/1ZWPbAqCcM2ijkS.png)

### 2.2复习类型

| strlen()      | 计算字符串 **str** 的长度，直到空结束字符，但不包括空结束字符。 |
| ------------- | ------------------------------------------------------------ |
| size_t        | size_t 类型表示C中任何对象所能达到的最大长度，它是无符号整数。 |
| malloc（）    | 动态分配内存空间。用 malloc() 时通常需要进行强制类型转换，将 void 指针转换成我们希望的类型 |
| strcpy（x,y） | **char \*strcpy(char \*dest, const char \*src)** 。把 **src** 所指向的字符串**复制**到 **dest** |
| const         | 它限定一个变量不允许被改变，产生静态作用                     |
| strcat()      | char * strcat ( char * dest , const char * src ) 。把**src**所框架的字符串追加到**dest**所框架的字符串结尾,大白话，把str2**连接**到str1后面 |
| strcmp()      | 把 **str1** 所指向的字符串和 **str2** 所指向的字符串进行比较。基于ASCLL码 |



### 2.3进入Decry()

反汇编ctrl+f5

![image-20211011193605821](https://i.loli.net/2021/10/11/4MlKYgwhxIRGEmq.png)

高亮区域为十六进制数据

猜测为字符串，右击数据，进行char转换

对此页十六进制数据均进行char转换

或许说，对于新手来说不太友好？

option->Disassembly->勾选Auto  Comments

![image-20211011203854393](https://i.loli.net/2021/10/11/NVTJUdhZkisPQCm.png)

效果：

![image-20211011204247766](https://i.loli.net/2021/10/11/n9YThSfKdDrx7v3.png)





[IDA PRO 使用技巧总结](https://www.52pojie.cn/thread-886103-1-1.html)

转换后如下图所示：

![image-20211011193710898](https://i.loli.net/2021/10/11/wOrac6ifvTDp4H1.png)

源码：

unsigned __int64 Decry()
{
  char v1; // [rsp+Fh] [rbp-51h]
  int v2; // [rsp+10h] [rbp-50h]
  int v3; // [rsp+14h] [rbp-4Ch]
  int i; // [rsp+18h] [rbp-48h]
  int v5; // [rsp+1Ch] [rbp-44h]
  char src[8]; // [rsp+20h] [rbp-40h] BYREF
  __int64 v7; // [rsp+28h] [rbp-38h]
  int v8; // [rsp+30h] [rbp-30h]
  __int64 v9[2]; // [rsp+40h] [rbp-20h] BYREF
  int v10; // [rsp+50h] [rbp-10h]
  unsigned __int64 v11; // [rsp+58h] [rbp-8h]

  v11 = __readfsqword(0x28u);
  *(_QWORD *)src = 'SLCDN';
  v7 = 0LL;
  v8 = 0;
  v9[0] = 'wodah';
  v9[1] = 0LL;
  v10 = 0;
  text = join(key3, (const char *)v9);
  strcpy(key, key1);
  strcat(key, src);
  v2 = 0;
  v3 = 0;
  getchar();
  v5 = strlen(key);
  for ( i = 0; i < v5; ++i )
  {
    if ( key[v3 % v5] > 64 && key[v3 % v5] <= 90 )
      key[i] = key[v3 % v5] + 32;
    ++v3;
  }
  printf("Please input your flag:");
  while ( 1 )
  {
    v1 = getchar();
    if ( v1 == 10 )
      break;
    if ( v1 == 32 )
    {
      ++v2;
    }
    else
    {
      if ( v1 <= 96 || v1 > 122 )
      {
        if ( v1 > 64 && v1 <= 90 )
        {
          str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;
          ++v3;
        }
      }
      else
      {
        str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;
        ++v3;
      }
      if ( !(v3 % v5) )
        putchar(32);
      ++v2;
    }
  }
  if ( !strcmp(text, str2) )
    puts("Congratulation!\n");
  else
    puts("Try again!\n");
  return __readfsqword('(') ^ v11;
}

### 2.4分析Decry()源码

![image-20211012133522484](https://i.loli.net/2021/10/12/3kzVtNb7Clr28nY.png)





![image-20211012133504730](https://i.loli.net/2021/10/12/7RnZqlPEIyM5Y64.png)

#### 2.4.1判断

可以看到这里的两个十六进制是大端序（9开头），但是数据在内存中都是小端序，所以要将其，反转一下。一般在CPU，x86都是小端序，但是IDA将之转换为了大端序。

按R键，把char反转，src = NDCLS ， v9 = hadow 。

![image-20211011211038820](https://i.loli.net/2021/10/11/xWe6kdugtGCSKL7.png)

![image-20211011211108893](https://i.loli.net/2021/10/11/juI9CtkzSPJsrlG.png)

key3=kills

![image-20211011211235355](https://i.loli.net/2021/10/11/DhcRTPvdNAjLb57.png)

join函数，点进去！

![image-20211011211301493](https://i.loli.net/2021/10/11/BUEf3jIOApZx9z8.png)

#### 2.4.2字符操作



这里对key3和v9做了字符串连接

text=killshadow

strcpy将key1 copy 给 key

key1=ADSFK ->key=ADSFK

strcat拼接key和src

key=ADSFKNDCLS

![image-20211011211827162](https://i.loli.net/2021/10/11/BjPmk7RSfbiDghz.png)

计算key.length，v5=10



![image-20211011211947203](https://i.loli.net/2021/10/11/bkAIrZUfiqOHctn.png)



key>'@' || key<='Z'的字符要遵循以下条件：

key[i]+=32; //比原来字符ASCLL码大32

即key[v3%v5]若是大写字母，转换为小写

key=adsfkndcls



![image-20211012134540030](https://i.loli.net/2021/10/12/86EGNVvn4AyDOMd.png)



##### 2.4.2转换

将ASCLL码转换为字符

下面给出：

**标准ASCII编码表**

| ASCII码 | 字符   |          |                    |
| ------- | ------ | -------- | ------------------ |
| 16进制  | 10进制 | 2进制    |                    |
| 0x00    | 0      | 00000000 | NUL 空             |
| 0x01    | 1      | 00000001 | SOH 标题开始       |
| 0x02    | 2      | 00000010 | STX 正文开始       |
| 0x03    | 3      | 00000011 | ETX 正文结束       |
| 0x04    | 4      | 00000100 | EOT 传输结束       |
| 0x05    | 5      | 00000101 | ENQ 询问字符       |
| 0x06    | 6      | 00000110 | ACK 承认           |
| 0x07    | 7      | 00000111 | BEL 报警           |
| 0x08    | 8      | 00001000 | BS  退一格         |
| 0x09    | 9      | 00001001 | HT  横向制表       |
| 0x0A    | 10     | 00001010 | LF  换行           |
| 0x0B    | 11     | 00001011 | VT  垂直制表       |
| 0x0C    | 12     | 00001100 | FF  走纸控制       |
| 0x0D    | 13     | 00001101 | CR  回车           |
| 0x0E    | 14     | 00001110 | SO  移位输出       |
| 0x0F    | 15     | 00001111 | SI  移位输入       |
| 0x10    | 16     | 00010000 | DLE 数据链路转义   |
| 0x11    | 17     | 00010001 | DC1 设备控制1      |
| 0x12    | 18     | 00010010 | DC2 设备控制2      |
| 0x13    | 19     | 00010011 | DC3 设备控制3      |
| 0x14    | 20     | 00010100 | DC4 设备控制4      |
| 0x15    | 21     | 00010101 | NAK 否定           |
| 0x16    | 22     | 00010110 | SYN 空转同步       |
| 0x17    | 23     | 00010111 | ETB 信息组传送结束 |
| 0x18    | 24     | 00011000 | CAN 作废           |
| 0x19    | 25     | 00011001 | EM  纸尽           |
| 0x1A    | 26     | 00011010 | SUB 换置           |
| 0x1B    | 27     | 00011011 | ESC 换码           |
| 0x1C    | 28     | 00011100 | FS  文字分隔符     |
| 0x1D    | 29     | 00011101 | GS  组分隔符       |
| 0x1E    | 30     | 00011110 | RS  记录分隔符     |
| 0x1F    | 31     | 00011111 | US  单元分隔符     |
| 0x20    | 32     | 00100000 | (space)            |
| 0x21    | 33     | 00100001 | ！                 |
| 0x22    | 34     | 00100010 | ”                  |
| 0x23    | 35     | 00100011 | #                  |
| 0x24    | 36     | 00100100 | $                  |
| 0x25    | 37     | 00100101 | %                  |
| 0x26    | 38     | 00100110 | &                  |
| 0x27    | 39     | 00100111 | '                  |
| 0x28    | 40     | 00101000 | (                  |
| 0x29    | 41     | 00101001 | )                  |
| 0x2A    | 42     | 00101010 | *                  |
| 0x2B    | 43     | 00101011 | +                  |
| 0x2C    | 44     | 00101100 | ,                  |
| 0x2D    | 45     | 00101101 | -                  |
| 0x2E    | 46     | 00101110 | .                  |
| 0x2F    | 47     | 00101111 | /                  |
| 0x30    | 48     | 00110000 | 0                  |
| 0x31    | 49     | 00110001 | 1                  |
| 0x32    | 50     | 00110010 | 2                  |
| 0x33    | 51     | 00110011 | 3                  |
| 0x34    | 52     | 00110100 | 4                  |
| 0x35    | 53     | 00110101 | 5                  |
| 36      | 54     | 00110110 | 6                  |
| 0x37    | 55     | 00110111 | 7                  |
| 0x38    | 56     | 00111000 | 8                  |
| 0x39    | 57     | 00111001 | 9                  |
| 0x3A    | 58     | 00111010 | :                  |
| 0x3B    | 59     | 00111011 | ;                  |
| 0x3C    | 60     | 00111100 | <                  |
| 0x3D    | 61     | 00111101 | =                  |
| 0x3E    | 62     | 00111110 | >                  |
| 0x3F    | 63     | 00111111 | ?                  |
| 0x40    | 64     | 01000000 | @                  |
| 0x41    | 65     | 01000001 | A                  |
| 0x42    | 66     | 01000010 | B                  |
| 0x43    | 67     | 01000011 | C                  |
| 0x44    | 68     | 01000100 | D                  |
| 0x45    | 69     | 01000101 | E                  |
| 0x46    | 70     | 01000110 | F                  |
| 0x47    | 71     | 01000111 | G                  |
| 0x48    | 72     | 01001000 | H                  |
| 0x49    | 73     | 01001001 | I                  |
| 0x4A    | 74     | 01001010 | J                  |
| 0x4B    | 75     | 01001011 | K                  |
| 0x4C    | 76     | 01001100 | L                  |
| 0x4D    | 77     | 01001101 | M                  |
| 0x4E    | 78     | 01001110 | N                  |
| 0x4F    | 79     | 01001111 | O                  |
| 0x50    | 80     | 01010000 | P                  |
| 0x51    | 81     | 01010001 | Q                  |
| 0x52    | 82     | 01010010 | R                  |
| 0x53    | 83     | 01010011 | S                  |
| 0x54    | 84     | 01010100 | T                  |
| 0x55    | 85     | 01010101 | U                  |
| 0x56    | 86     | 01010110 | V                  |
| 0x57    | 87     | 01010111 | W                  |
| 0x58    | 88     | 01011000 | X                  |
| 0x59    | 89     | 01011001 | Y                  |
| 0x5A    | 90     | 01011010 | Z                  |
| 0x5B    | 91     | 01011011 | [                  |
| 0x5C    | 92     | 01011100 | \                  |
| 0x5D    | 93     | 01011101 | ]                  |
| 0x5E    | 94     | 01011110 | ^                  |
| 0x5F    | 95     | 01011111 | _                  |
| 0x60    | 96     | 01100000 | `                  |
| 0x61    | 97     | 01100001 | a                  |
| 0x62    | 98     | 01100010 | b                  |
| 0x63    | 99     | 01100011 | c                  |
| 0x64    | 100    | 01100100 | d                  |
| 0x65    | 101    | 01100101 | e                  |
| 0x66    | 102    | 01100110 | f                  |
| 0x67    | 103    | 01100111 | g                  |
| 0x68    | 104    | 01101000 | h                  |
| 0x69    | 105    | 01101001 | i                  |
| 0x6A    | 106    | 01101010 | j                  |
| 0x6B    | 107    | 01101011 | k                  |
| 0x6C    | 108    | 01101100 | l                  |
| 0x6D    | 109    | 01101101 | m                  |
| 0x6E    | 110    | 01101110 | n                  |
| 0x6F    | 111    | 01101111 | o                  |
| 0x70    | 112    | 01110000 | p                  |
| 0x71    | 113    | 01110001 | q                  |
| 0x72    | 114    | 01110010 | r                  |
| 0x73    | 115    | 01110011 | s                  |
| 0x74    | 116    | 01110100 | t                  |
| 0x75    | 117    | 01110101 | u                  |
| 0x76    | 118    | 01110110 | v                  |
| 0x77    | 119    | 01110111 | w                  |
| 0x78    | 120    | 01111000 | x                  |
| 0x79    | 121    | 01111001 | y                  |
| 0x7A    | 122    | 01111010 | z                  |
| 0x7B    | 123    | 01111011 | {                  |
| 0x7C    | 124    | 01111100 | \|                 |
| 0x7D    | 125    | 01111101 | }                  |
| 0x7E    | 126    | 01111110 | ~                  |
| 0x7F    | 127    | 01111111 | DEL 删除           |

[ASCLL码转换器](https://www.qqxiuzi.cn/bianma/ascii.htm)

结果为：

v1（输入的flag）

if(v1==' '){++v2,}//每当v1读入一次空格，v2变化

else{

if(96-`   122-z){	

​			if(64-@	90-Z ){str2[v2]...++v3;}  //26位大写字母转化为小写

​		else{str2[v2]...++v3;}//小写字母保留

if(!(v3 % v5) )

putchar(‘ ’); 	//若不是指定字符串则输出(space)

++v2;				//v2变化

​	}	

}		

if(!strcmp(text,str2) )

puts("Congratulation!\n");

//若字符串相同，则正确，返回值0，此时text=str2才成功

##### 2.4.2str2怎么找？

str2[v2]=(v1-39-key[v3 % v5]+97)%26+97;

在遇到space时，v3会叠加，此时能逐个字符输入str2

#### 2.5提炼代码，编辑脚本求flag

![image-20211012151101443](https://i.loli.net/2021/10/12/PyOabvudz5WpLTK.png)

\#include<stdio.h>

int main()

{

  char key[]="adsfkndcls";

  char text[]="killshadow";

  int i;

  int v2=0;

  int v3=10;                //遍历key得到key.length=10，10个英文字符，大写转小写变换10次，v3累加10次

  int v5=10;                //遍历key得到v5=key.length=10

  for(int i=0;i<v5;i++){

​    for(int j=0;j<123;j++){       //str2[v2]=(v1-39-key[v3 % v5]+97)%26+97;最大值为122=25+97,包含了26个小写字符的ASCLL码，97~122

​                      //循环初，v3%v5=0，从key[0]开始，v3随大小写变化不断累加，实现遍历key

​      if((j<'A'||j>'Z')||(j<'z'&& j>'a'))    

​        {continue;}          //非英文字符的字符忽略不计  

​      if((j-39-key[v3%v5]+97)%26+97==text[i])  //

​        {printf("%c",j);

​          v3++;

​          break;}                          

​               }

​            }

}



flag{KLDQCUDFZO}